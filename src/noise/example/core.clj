(ns noise.example.core
  (:require [noise.core :as noise]
            [clojure.core.reducers :as reducers])
  (:import (java.awt.image BufferedImage)
           (java.awt Color Dimension Frame)
           (javax.imageio ImageIO)
           (java.io File)
           (java.util Date)))

(defn noise-range [max]
  (range 1 (inc max)))

(def default-noise-gen
  "A default noise generator to make examples easier to work with"
  (noise/new-noise-gen 0))

(defn rand-noise-gen []
  "A noise generator with a random seed"
  (noise/new-noise-gen (.getTime (Date.))))

(defn standard-noise
  "standard terrain-like noise"
  ([noise-gen x y]
   (noise/scale (noise/fbm noise-gen 5 0.5 0.01 [x y]) 0 255))
  ([x y] (standard-noise default-noise-gen x y)))

(defn staged-noise
  "build noise in multiple stages.
  Chunky sets the general shape, increasing local grouping
  and refined applies the motion"
  ([noise-gen x y]
   (let [chunky (noise/scale (noise/fbm noise-gen 1 0 0.003 [x y]) 0 255)
         refined (noise/scale (noise/fbm noise-gen 6 0.52 0.01 [x y]) 0 255)]
     (+ (* 0.5 chunky) (* 0.5 refined))))
  ([x y] (staged-noise default-noise-gen x y)))

(defn- color [r g b]
  (.getRGB (Color. (int r) (int g) (int b))))

(defn colorize-earth [grey]
  "earth-like coloring (e.g. green and blue)"
  (if (< 138 grey)
    (color 0 grey 0)
    (color 0 0 grey)))

(defn colorize-greyscale [grey]
  "simple greyscale coloring"
  (color grey grey grey))

; for some reason, cartesian-product noise-pixels functions are MUCH slower than the for loop
(defn noise-pixels-parallel [width height get-noise colorize]
  "returns a seq (using a cartesian product) of noise of size width * height,
   with the given noise and color functions"
  (let [coords (for [x (noise-range width) y (noise-range height)] [x y])]
    (into () (reducers/map #(colorize (int (apply get-noise %))) coords))))

(defn noise-pixels-cartesian [width height get-noise colorize]
  "returns a seq (using a cartesian product) of noise of size width * height,
   with the given noise and color functions"
  (let [coords (for [x (noise-range width) y (noise-range height)] [x y])]
    (map #(colorize (int (apply get-noise %))) coords)))

(defn noise-pixels-for [width height get-noise colorize]
  "returns a seq (using a for loop) of noise of size width * height,
   with the given noise and color functions"
  (for [x (noise-range width)
        y (noise-range height)]
    (colorize (int (get-noise x y)))))

(defn make-image [width height noise-pixels get-noise colorize]
  "Make an image with the given noise characteristics"
  (let [img (BufferedImage. width height BufferedImage/TYPE_INT_RGB)
        raster (.getRaster img)
        pixels (int-array (noise-pixels width height get-noise colorize))]
    (.setDataElements raster 0 0 width height pixels)
    img))

(defn save-image [image path]
  "convenience method to save the given image to the given path"
  (ImageIO/write image "png" (File. path)))

(defn make-frame [width height]
  "convenience method to make an AWT fram of dimensions size x size"
  (let [frame (Frame.)]
    (.setSize frame (Dimension. width height))
    (.setVisible frame true)
    frame))

(defn noise-frame
  "fill the given frame with noise generated by the given noise and color functions"
  ([^Frame frame noise-pixels get-noise colorize]
   (let [gfx (.getGraphics frame)
         width (.getWidth frame)
         height (.getHeight frame)
         img (make-image width height noise-pixels get-noise colorize)]
     (.drawImage gfx img 0 0 nil)))
  ([frame]
   (noise-frame frame noise-pixels-for standard-noise colorize-greyscale)))
